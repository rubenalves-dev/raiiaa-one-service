// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: time-entries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getUnbillableTimeEntries = `-- name: GetUnbillableTimeEntries :many
SELECT te.id, te.task_id, te.user_id, te.start_time, te.end_time, te.description, te.is_billable, te.created_at, te.updated_at, t.id, t.project_id, t.user_id, t.title, t.description, t.status, t.priority, t.due_date, t.estimated_minutes, t.created_at, t.updated_at, p.id, p.client_id, p.user_id, p.name, p.description, p.deadline, p.color, p.status, p.hourly_rate, p.budget, p.repo_url, p.live_url, p.created_at, p.updated_at FROM time_entries te
JOIN tasks t ON te.task_id = t.id
JOIN projects p ON te.project_id = p.id
WHERE te.user_id = $1 AND te.is_billable = false AND te.end_time IS NOT NULL
ORDER BY te.start_time DESC
`

type GetUnbillableTimeEntriesRow struct {
	TimeEntry TimeEntry `json:"time_entry"`
	Task      Task      `json:"task"`
	Project   Project   `json:"project"`
}

func (q *Queries) GetUnbillableTimeEntries(ctx context.Context, userID uuid.UUID) ([]GetUnbillableTimeEntriesRow, error) {
	rows, err := q.db.Query(ctx, getUnbillableTimeEntries, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnbillableTimeEntriesRow
	for rows.Next() {
		var i GetUnbillableTimeEntriesRow
		if err := rows.Scan(
			&i.TimeEntry.ID,
			&i.TimeEntry.TaskID,
			&i.TimeEntry.UserID,
			&i.TimeEntry.StartTime,
			&i.TimeEntry.EndTime,
			&i.TimeEntry.Description,
			&i.TimeEntry.IsBillable,
			&i.TimeEntry.CreatedAt,
			&i.TimeEntry.UpdatedAt,
			&i.Task.ID,
			&i.Task.ProjectID,
			&i.Task.UserID,
			&i.Task.Title,
			&i.Task.Description,
			&i.Task.Status,
			&i.Task.Priority,
			&i.Task.DueDate,
			&i.Task.EstimatedMinutes,
			&i.Task.CreatedAt,
			&i.Task.UpdatedAt,
			&i.Project.ID,
			&i.Project.ClientID,
			&i.Project.UserID,
			&i.Project.Name,
			&i.Project.Description,
			&i.Project.Deadline,
			&i.Project.Color,
			&i.Project.Status,
			&i.Project.HourlyRate,
			&i.Project.Budget,
			&i.Project.RepoUrl,
			&i.Project.LiveUrl,
			&i.Project.CreatedAt,
			&i.Project.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTimeEntriesByRange = `-- name: ListTimeEntriesByRange :many
SELECT te.id, te.task_id, te.user_id, te.start_time, te.end_time, te.description, te.is_billable, te.created_at, te.updated_at, t.id, t.project_id, t.user_id, t.title, t.description, t.status, t.priority, t.due_date, t.estimated_minutes, t.created_at, t.updated_at, p.id, p.client_id, p.user_id, p.name, p.description, p.deadline, p.color, p.status, p.hourly_rate, p.budget, p.repo_url, p.live_url, p.created_at, p.updated_at, c.id, c.user_id, c.company_name, c.contact_name, c.contact_email, c.contact_phone, c.address, c.notes, c.archived_at, c.created_at, c.updated_at FROM time_entries te
JOIN tasks t ON te.task_id = t.id
JOIN projects p ON te.project_id = p.id
LEFT JOIN clients c ON p.client_id = c.id
WHERE te.user_id = $1 AND te.start_time >= $2 AND (te.end_time <= $3 OR te.end_time IS NULL)
ORDER BY te.start_time DESC
`

type ListTimeEntriesByRangeParams struct {
	UserID    uuid.UUID          `json:"user_id"`
	StartTime pgtype.Timestamptz `json:"start_time"`
	EndTime   pgtype.Timestamptz `json:"end_time"`
}

type ListTimeEntriesByRangeRow struct {
	TimeEntry TimeEntry `json:"time_entry"`
	Task      Task      `json:"task"`
	Project   Project   `json:"project"`
	Client    Client    `json:"client"`
}

func (q *Queries) ListTimeEntriesByRange(ctx context.Context, arg ListTimeEntriesByRangeParams) ([]ListTimeEntriesByRangeRow, error) {
	rows, err := q.db.Query(ctx, listTimeEntriesByRange, arg.UserID, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTimeEntriesByRangeRow
	for rows.Next() {
		var i ListTimeEntriesByRangeRow
		if err := rows.Scan(
			&i.TimeEntry.ID,
			&i.TimeEntry.TaskID,
			&i.TimeEntry.UserID,
			&i.TimeEntry.StartTime,
			&i.TimeEntry.EndTime,
			&i.TimeEntry.Description,
			&i.TimeEntry.IsBillable,
			&i.TimeEntry.CreatedAt,
			&i.TimeEntry.UpdatedAt,
			&i.Task.ID,
			&i.Task.ProjectID,
			&i.Task.UserID,
			&i.Task.Title,
			&i.Task.Description,
			&i.Task.Status,
			&i.Task.Priority,
			&i.Task.DueDate,
			&i.Task.EstimatedMinutes,
			&i.Task.CreatedAt,
			&i.Task.UpdatedAt,
			&i.Project.ID,
			&i.Project.ClientID,
			&i.Project.UserID,
			&i.Project.Name,
			&i.Project.Description,
			&i.Project.Deadline,
			&i.Project.Color,
			&i.Project.Status,
			&i.Project.HourlyRate,
			&i.Project.Budget,
			&i.Project.RepoUrl,
			&i.Project.LiveUrl,
			&i.Project.CreatedAt,
			&i.Project.UpdatedAt,
			&i.Client.ID,
			&i.Client.UserID,
			&i.Client.CompanyName,
			&i.Client.ContactName,
			&i.Client.ContactEmail,
			&i.Client.ContactPhone,
			&i.Client.Address,
			&i.Client.Notes,
			&i.Client.ArchivedAt,
			&i.Client.CreatedAt,
			&i.Client.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startTimer = `-- name: StartTimer :one
INSERT INTO time_entries (user_id, task_id, start_time, description, is_billable)
VALUES ($1, $2, NOW(), $3, $4)
RETURNING id, task_id, user_id, start_time, end_time, description, is_billable, created_at, updated_at
`

type StartTimerParams struct {
	UserID      uuid.UUID   `json:"user_id"`
	TaskID      uuid.UUID   `json:"task_id"`
	Description pgtype.Text `json:"description"`
	IsBillable  pgtype.Bool `json:"is_billable"`
}

func (q *Queries) StartTimer(ctx context.Context, arg StartTimerParams) (TimeEntry, error) {
	row := q.db.QueryRow(ctx, startTimer,
		arg.UserID,
		arg.TaskID,
		arg.Description,
		arg.IsBillable,
	)
	var i TimeEntry
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.UserID,
		&i.StartTime,
		&i.EndTime,
		&i.Description,
		&i.IsBillable,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const stopTimer = `-- name: StopTimer :one
UPDATE time_entries
SET end_time = NOW(), updated_at = NOW()
WHERE id = $1 AND end_time IS NULL
RETURNING id, task_id, user_id, start_time, end_time, description, is_billable, created_at, updated_at
`

func (q *Queries) StopTimer(ctx context.Context, id int32) (TimeEntry, error) {
	row := q.db.QueryRow(ctx, stopTimer, id)
	var i TimeEntry
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.UserID,
		&i.StartTime,
		&i.EndTime,
		&i.Description,
		&i.IsBillable,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const stopTimerForUser = `-- name: StopTimerForUser :one
UPDATE time_entries
SET end_time = NOW(), updated_at = NOW()
WHERE user_id = $1 AND end_time IS NULL
RETURNING id, task_id, user_id, start_time, end_time, description, is_billable, created_at, updated_at
`

func (q *Queries) StopTimerForUser(ctx context.Context, userID uuid.UUID) (TimeEntry, error) {
	row := q.db.QueryRow(ctx, stopTimerForUser, userID)
	var i TimeEntry
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.UserID,
		&i.StartTime,
		&i.EndTime,
		&i.Description,
		&i.IsBillable,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
