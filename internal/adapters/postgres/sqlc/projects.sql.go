// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projects.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createProject = `-- name: CreateProject :one
INSERT INTO projects (user_id, client_id, name, description, status, color, deadline, hourly_rate, budget, repo_url, live_url)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, client_id, user_id, name, description, deadline, color, status, hourly_rate, budget, repo_url, live_url, created_at, updated_at
`

type CreateProjectParams struct {
	UserID      uuid.UUID         `json:"user_id"`
	ClientID    pgtype.UUID       `json:"client_id"`
	Name        string            `json:"name"`
	Description pgtype.Text       `json:"description"`
	Status      NullProjectStatus `json:"status"`
	Color       pgtype.Text       `json:"color"`
	Deadline    pgtype.Date       `json:"deadline"`
	HourlyRate  pgtype.Int4       `json:"hourly_rate"`
	Budget      pgtype.Int8       `json:"budget"`
	RepoUrl     pgtype.Text       `json:"repo_url"`
	LiveUrl     pgtype.Text       `json:"live_url"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.UserID,
		arg.ClientID,
		arg.Name,
		arg.Description,
		arg.Status,
		arg.Color,
		arg.Deadline,
		arg.HourlyRate,
		arg.Budget,
		arg.RepoUrl,
		arg.LiveUrl,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Deadline,
		&i.Color,
		&i.Status,
		&i.HourlyRate,
		&i.Budget,
		&i.RepoUrl,
		&i.LiveUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listProjectsByClientID = `-- name: ListProjectsByClientID :many
SELECT id, client_id, user_id, name, description, deadline, color, status, hourly_rate, budget, repo_url, live_url, created_at, updated_at FROM projects
WHERE user_id = $1 AND client_id = $2
ORDER BY deadline ASC
`

type ListProjectsByClientIDParams struct {
	UserID   uuid.UUID   `json:"user_id"`
	ClientID pgtype.UUID `json:"client_id"`
}

func (q *Queries) ListProjectsByClientID(ctx context.Context, arg ListProjectsByClientIDParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjectsByClientID, arg.UserID, arg.ClientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Deadline,
			&i.Color,
			&i.Status,
			&i.HourlyRate,
			&i.Budget,
			&i.RepoUrl,
			&i.LiveUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsByUserID = `-- name: ListProjectsByUserID :many
SELECT id, client_id, user_id, name, description, deadline, color, status, hourly_rate, budget, repo_url, live_url, created_at, updated_at FROM projects
WHERE user_id = $1
ORDER BY deadline DESC
`

func (q *Queries) ListProjectsByUserID(ctx context.Context, userID uuid.UUID) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjectsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Deadline,
			&i.Color,
			&i.Status,
			&i.HourlyRate,
			&i.Budget,
			&i.RepoUrl,
			&i.LiveUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
